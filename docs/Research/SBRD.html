<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Utility functions (please skip to the next section)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../images/logo.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-3f13cc09417cf69baaf74afa0e2e3cf6.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../images/logo.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <span class="nav-link">
<span class="menu-text">Domenico Mergoni Cecchelli</span>
    </span>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Learning/Learning.html">Learning</a></li><li class="breadcrumb-item">Python</li><li class="breadcrumb-item"><a href="../Research/SBRD.html">Research</a></li><li class="breadcrumb-item"><a href="../Research/SBRD.html">SBRD in Random Games</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homepage</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Teaching/Teaching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Teaching</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../Learning/Learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Learning</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Research</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth3 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Research/SBRD.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">SBRD in Random Games</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false">
 <span class="menu-text">Useful</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Learning/Python/Useful/Arxiv.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Arxiv</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Learning/Python/Useful/Greatest_authors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Greatest Authors</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false">
 <span class="menu-text">Codeforces</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth3 ">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false">
 <span class="menu-text">Easy</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth4 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Learning/Python/CF/Easy/1758A.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1758A</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false">
 <span class="menu-text">Old Notes</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Learning/Old_Work/OldWork.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Old Work</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Research/research.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Research</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../main_pages/curriculum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Curriculum Vitae</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../main_pages/miscellanea.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Miscellanea</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#dynamics-definitions" id="toc-dynamics-definitions" class="nav-link active" data-scroll-target="#dynamics-definitions">Dynamics definitions</a></li>
  <li><a href="#main-results" id="toc-main-results" class="nav-link" data-scroll-target="#main-results">Main Results</a>
  <ul class="collapse">
  <li><a href="#section-1.-finding-2-player-random-potential-games-converge-fast-to-a-two-cycle" id="toc-section-1.-finding-2-player-random-potential-games-converge-fast-to-a-two-cycle" class="nav-link" data-scroll-target="#section-1.-finding-2-player-random-potential-games-converge-fast-to-a-two-cycle">Section 1. Finding: 2-player random potential games converge fast to a two-cycle</a></li>
  <li><a href="#section-2.-finding-3-player-random-potential-games-converge-fast-to-a-ne" id="toc-section-2.-finding-3-player-random-potential-games-converge-fast-to-a-ne" class="nav-link" data-scroll-target="#section-2.-finding-3-player-random-potential-games-converge-fast-to-a-ne">Section 2. Finding: 3-player random potential games converge fast to a NE</a></li>
  <li><a href="#section-3.-finding-comparison-of-sbrd-and-spgd-in-3-player-random-potential-games" id="toc-section-3.-finding-comparison-of-sbrd-and-spgd-in-3-player-random-potential-games" class="nav-link" data-scroll-target="#section-3.-finding-comparison-of-sbrd-and-spgd-in-3-player-random-potential-games">Section 3. Finding: comparison of SBRD and SPGD in 3-player random potential games</a></li>
  </ul></li>
  <li><a href="#appendix" id="toc-appendix" class="nav-link" data-scroll-target="#appendix">Appendix</a>
  <ul class="collapse">
  <li><a href="#section-a.-results-of-section-1.-also-hold-for-more-actions" id="toc-section-a.-results-of-section-1.-also-hold-for-more-actions" class="nav-link" data-scroll-target="#section-a.-results-of-section-1.-also-hold-for-more-actions">Section A. Results of Section 1. also hold for more actions</a></li>
  <li><a href="#section-b.1.-results-of-section-2.-also-hold-for-more-actions" id="toc-section-b.1.-results-of-section-2.-also-hold-for-more-actions" class="nav-link" data-scroll-target="#section-b.1.-results-of-section-2.-also-hold-for-more-actions">Section B.1. Results of Section 2. also hold for more actions</a></li>
  <li><a href="#section-b.2.-results-of-section-2.-also-hold-for-more-players" id="toc-section-b.2.-results-of-section-2.-also-hold-for-more-players" class="nav-link" data-scroll-target="#section-b.2.-results-of-section-2.-also-hold-for-more-players">Section B.2. Results of Section 2. also hold for more players</a></li>
  <li><a href="#section-c.1.-results-of-section-3.-also-hold-for-more-actions" id="toc-section-c.1.-results-of-section-3.-also-hold-for-more-actions" class="nav-link" data-scroll-target="#section-c.1.-results-of-section-3.-also-hold-for-more-actions">Section C.1. Results of Section 3. also hold for more actions</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Learning/Learning.html">Learning</a></li><li class="breadcrumb-item">Python</li><li class="breadcrumb-item"><a href="../Research/SBRD.html">Research</a></li><li class="breadcrumb-item"><a href="../Research/SBRD.html">SBRD in Random Games</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Utility functions (please skip to the next section)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div id="c9fe19ab-b5ce-4604-859d-505960356aaa" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> beta</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> <span class="bu">reduce</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> operator <span class="im">import</span> matmul </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="0fbf9a91" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> softmax(r):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a softmax function.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    exp_r <span class="op">=</span> np.exp(r <span class="op">-</span> np.<span class="bu">max</span>(r))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp_r <span class="op">/</span> np.<span class="bu">sum</span>(exp_r)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gradient_ascent_dynamics(G, n, eta<span class="op">=</span><span class="fl">1.0</span>, max_iter<span class="op">=</span><span class="dv">50_000</span>, T_max<span class="op">=</span><span class="dv">10</span>): </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># The following function implements a (softmax) gradient ascent algorithm for a 3-player game with n actions.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># It takes the number of actions n, a correlation parameter lam, a learning rate eta, a max iteration count,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># and a tolerance for convergence as inputs. It returns the average payoff, the number of iterations,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># and the final payoff for player 0.    </span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    t_0 <span class="op">=</span> time()</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialise each player's "logit" vector (which will be mapped to a mixed strategy via softmax).</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    r0 <span class="op">=</span> np.zeros(n)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    r1 <span class="op">=</span> np.zeros(n)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    r2 <span class="op">=</span> np.zeros(n)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    total_payoff <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert logits to mixed strategies.</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        p0 <span class="op">=</span> softmax(r0)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        p1 <span class="op">=</span> softmax(r1)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        p2 <span class="op">=</span> softmax(r2)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute the expected payoff for each pure action for each player.</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For player 0: Q0[i] = sum_{j,k} p1[j] p2[k] G[0][i, j, k]</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        Q0 <span class="op">=</span> np.array([np.dot(p1, np.dot(G[<span class="dv">0</span>][i, :n, :n], p2)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For player 1: Q1[i] = sum_{j,k} p0[j] p2[k] G[1][j, i, k]</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        Q1 <span class="op">=</span> np.array([np.dot(p0, np.dot(G[<span class="dv">1</span>][:n, i, :n], p2)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For player 2: Q2[i] = sum_{j,k} p0[j] p1[k] G[2][j, k, i]</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        Q2 <span class="op">=</span> np.array([np.dot(p0, np.dot(G[<span class="dv">2</span>][:n, :n, i], p1)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute the overall expected payoff for each player.</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        f0 <span class="op">=</span> np.dot(p0, Q0)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        f1 <span class="op">=</span> np.dot(p1, Q1)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        f2 <span class="op">=</span> np.dot(p2, Q2)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Accumulate payoff for averaging.</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        total_payoff <span class="op">+=</span> f0</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Every 100 iterations, check if the current strategy profile is an epsilon-NE.</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it <span class="op">%</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>            best0 <span class="op">=</span> np.<span class="bu">max</span>(Q0)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>            best1 <span class="op">=</span> np.<span class="bu">max</span>(Q1)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>            best2 <span class="op">=</span> np.<span class="bu">max</span>(Q2)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ((f0 <span class="op">&gt;=</span> <span class="fl">0.99</span> <span class="op">*</span> best0) <span class="kw">and</span> (f1 <span class="op">&gt;=</span> <span class="fl">0.99</span> <span class="op">*</span> best1) <span class="kw">and</span> (f2 <span class="op">&gt;=</span> <span class="fl">0.99</span> <span class="op">*</span> best2)) <span class="kw">or</span> (time()<span class="op">-</span>t_0 <span class="op">&gt;</span> T_max):</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        grad_r0 <span class="op">=</span> Q0 <span class="op">-</span> f0</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        grad_r1 <span class="op">=</span> Q1 <span class="op">-</span> f1</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        grad_r2 <span class="op">=</span> Q2 <span class="op">-</span> f2</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the logits using a simple gradient ascent step.</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>        r0 <span class="op">+=</span> eta <span class="op">*</span> grad_r0 </span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        r1 <span class="op">+=</span> eta <span class="op">*</span> grad_r1 </span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        r2 <span class="op">+=</span> eta <span class="op">*</span> grad_r2 </span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    avg_payoff <span class="op">=</span> total_payoff <span class="op">/</span> it</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> it, avg_payoff, f0</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Hyperparameters for gradient ascent. These numbers have been selected after some trial and error, and provided the best results for this algorithm.</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>step_size <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>max_iterations <span class="op">=</span> <span class="dv">50_000</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These are utility function only used to plot</p>
<div id="7be73528" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clopper_pearson_interval(k, n, alpha<span class="op">=</span><span class="fl">0.005</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> beta.ppf(alpha <span class="op">/</span> <span class="dv">2</span>, k, n <span class="op">-</span> k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">if</span> k <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="fl">0.0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> beta.ppf(<span class="dv">1</span> <span class="op">-</span> alpha <span class="op">/</span> <span class="dv">2</span>, k <span class="op">+</span> <span class="dv">1</span>, n <span class="op">-</span> k) <span class="cf">if</span> k <span class="op">&lt;</span> n <span class="cf">else</span> <span class="fl">1.0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lower, upper</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"time"</span>, ylabel<span class="op">=</span><span class="va">None</span>, axis<span class="op">=</span><span class="dv">0</span>, mean_name<span class="op">=</span><span class="va">None</span>, variance<span class="op">=</span><span class="va">True</span>, only_if_conv<span class="op">=</span><span class="va">False</span>, log<span class="op">=</span><span class="va">False</span>, n_cols<span class="op">=</span><span class="dv">1</span>, number_of_plots<span class="op">=-</span><span class="dv">1</span>, binomial<span class="op">=</span><span class="va">False</span>, isPositive<span class="op">=</span><span class="va">False</span>, width<span class="op">=</span><span class="dv">6</span>, legend_loc <span class="op">=</span> <span class="st">"upper left"</span>, title<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Plot runtimes of a single algorithm (PGD or SBRD) in subplots, comparing across one parameter.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - alg_name: 'PGD' or 'SBRD'</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - varName: variable name suffix for accessing data (e.g., "Seconds" accesses PGD_Seconds or SBRD_Seconds)</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - axis: 0 or 1</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">        - 0: compare across N for each Lambda (row-wise)</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">        - 1: compare across Lambda for each N (column-wise)</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">    - variance: whether to include standard deviation shading</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">    - only_if_conv: whether to only include data when convergence was achieved (using *_isNash)</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">    - log: whether to plot on a log scale</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_cols: number of columns of subplots to create</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co">    - number_of_plots: number of subplots to show (-1 for all)</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co">    - lambda_vals: optional list/array of Lambda values</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co">    - A_vals: optional list/array of N values</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">    - binomial: whether the data is binomial (0-1 values)</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ylabel <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        ylabel <span class="op">=</span> varName</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If the function input "only_if_conv" is True, only include the cases in which the samples for which algorithm converges</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> <span class="bu">globals</span>()[<span class="ss">f"</span><span class="sc">{</span>alg_name<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>varName<span class="sc">}</span><span class="ss">"</span>]</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> only_if_conv:</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        isNash <span class="op">=</span> <span class="bu">globals</span>()[<span class="ss">f"</span><span class="sc">{</span>alg_name<span class="sc">}</span><span class="ss">_isNash"</span>]</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        masked_data <span class="op">=</span> np.where(isNash, data, np.nan)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        masked_data <span class="op">=</span> data</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates the matrix of means and the matrices needed for the Confidence Intervals.</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co">    If the data is Binary, the CI is done using the Clopper Pearson interval. If the data is real, we use the Standard Error</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    mean_data <span class="op">=</span> np.nanmean(masked_data, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> variance:</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        n_data <span class="op">=</span> np.<span class="bu">sum</span>(<span class="op">~</span>np.isnan(masked_data), axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> binomial:</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>            sum_data <span class="op">=</span> np.nansum(masked_data, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>            lower_bounds <span class="op">=</span> np.zeros_like(mean_data)</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>            upper_bounds <span class="op">=</span> np.ones_like(mean_data)</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(mean_data.shape[<span class="dv">0</span>]):</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(mean_data.shape[<span class="dv">1</span>]):</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> n_data[i, j] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>                        lower, upper <span class="op">=</span> clopper_pearson_interval(<span class="bu">int</span>(sum_data[i, j]), <span class="bu">int</span>(n_data[i, j]))</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>                        lower_bounds[i, j] <span class="op">=</span> lower</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>                        upper_bounds[i, j] <span class="op">=</span> upper</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>            SE_data <span class="op">=</span> np.sqrt(np.divide(np.nanvar(masked_data, axis<span class="op">=-</span><span class="dv">1</span>), n_data))</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>    L, N <span class="op">=</span> mean_data.shape</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" </span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a><span class="co">    Depending on wether we want the plots to be done along the 0 or 1 axis, we get different "get_mean", "get_lower" and "get_upper"</span></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a><span class="co">    functions, that take as input i and return the right vector (respectively the mean, lower and upper CI points) with that index.</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> axis <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>        num_plots <span class="op">=</span> L</span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>        x_vals <span class="op">=</span> A_vals </span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>        y_vals <span class="op">=</span> lambda_vals </span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>        get_mean <span class="op">=</span> <span class="kw">lambda</span> i: mean_data[i, :]</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> variance:</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> binomial:</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>                get_lower <span class="op">=</span> <span class="kw">lambda</span> i: lower_bounds[i, :]</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>                get_upper <span class="op">=</span> <span class="kw">lambda</span> i: upper_bounds[i, :]</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>                get_var <span class="op">=</span> <span class="kw">lambda</span> i: SE_data[i, :]</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>        label <span class="op">=</span> <span class="st">"Correlation λ"</span></span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">"Nr. actions"</span></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> axis <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>        num_plots <span class="op">=</span> N</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>        x_vals <span class="op">=</span> lambda_vals</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>        y_vals <span class="op">=</span> A_vals </span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>        get_mean <span class="op">=</span> <span class="kw">lambda</span> i: mean_data[:, i]</span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> variance:</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> binomial:</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>                get_lower <span class="op">=</span> <span class="kw">lambda</span> i: lower_bounds[:, i]</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>                get_upper <span class="op">=</span> <span class="kw">lambda</span> i: upper_bounds[:, i]</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>                get_var <span class="op">=</span> <span class="kw">lambda</span> i: SE_data[:, i]</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>        label <span class="op">=</span> <span class="st">"Nr. actions"</span></span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">"Correlation λ"</span></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Axis must be 0 (over Lambda) or 1 (over N)"</span>)</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a><span class="co">    We now create the structure for the plots</span></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> number_of_plots <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">or</span> number_of_plots <span class="op">&gt;=</span> num_plots:</span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(num_plots))</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> np.linspace(<span class="dv">0</span>, num_plots <span class="op">-</span> <span class="dv">1</span>, number_of_plots, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>    n_rows <span class="op">=</span> math.ceil(<span class="bu">len</span>(indices) <span class="op">/</span> n_cols)</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(n_rows, n_cols, figsize<span class="op">=</span>(width <span class="op">*</span> n_cols, <span class="dv">3</span> <span class="op">*</span> n_rows), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>    axes <span class="op">=</span> np.array(axes).flatten()</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> (<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span>) <span class="cf">if</span> alg_name <span class="op">==</span> <span class="st">"PGD"</span> <span class="cf">else</span> (<span class="fl">0.9</span>, <span class="fl">0.4</span>, <span class="fl">0.2</span>)</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a><span class="co">    We finally plot the various graphs</span></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, idx <span class="kw">in</span> <span class="bu">enumerate</span>(indices):</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[i]</span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>        ax.set_xlabel(xlabel)</span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> log:</span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>            ax.set_yscale(<span class="st">'log'</span>)</span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>            ydata <span class="op">=</span> get_mean(idx)</span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>            ymin <span class="op">=</span> np.nanmin(ydata)</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>            ymax <span class="op">=</span> np.nanmax(ydata)</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Round to nearest powers of 10</span></span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>            lower <span class="op">=</span> <span class="dv">10</span> <span class="op">**</span> np.floor(np.log10(ymin))</span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>            upper <span class="op">=</span> <span class="dv">10</span> <span class="op">**</span> np.ceil(np.log10(ymax))</span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>            ax.set_ylim(lower, upper)</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>        ax.plot(x_vals, get_mean(idx), color<span class="op">=</span>color, label<span class="op">=</span>mean_name <span class="cf">if</span> mean_name<span class="op">!=</span> <span class="va">None</span> <span class="cf">else</span> varName)</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> variance:</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> binomial:</span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>                ax.fill_between(x_vals, get_lower(idx), get_upper(idx), color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.2</span>, label<span class="op">=</span><span class="st">'99.5% CI'</span>)</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> isPositive:</span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>                    lower <span class="op">=</span> np.clip(get_mean(idx) <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>get_var(idx), <span class="dv">0</span>, <span class="va">None</span>)</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>                    upper <span class="op">=</span> np.clip(get_mean(idx) <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>get_var(idx), <span class="dv">0</span>, <span class="va">None</span>)</span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a>                ax.fill_between(x_vals, lower, upper, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.2</span>, label<span class="op">=</span><span class="st">'±2 SE'</span>)</span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>        ax.set_ylabel(ylabel)</span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> title <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>            ax.set_title(<span class="ss">f"</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span><span class="bu">round</span>(y_vals[idx], <span class="dv">2</span>)<span class="sc">}</span><span class="ss">, samples = </span><span class="sc">{</span>samples<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>            ax.set_title(title)</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a>        ax.legend(loc<span class="op">=</span>legend_loc)</span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>        ax.grid(<span class="va">True</span>)</span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(indices), <span class="bu">len</span>(axes)):</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>        fig.delaxes(axes[j])</span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout(rect<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.96</span>])</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="ss">f"</span><span class="sc">{</span>alg_name<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>varName<span class="sc">}</span><span class="ss">_samples=</span><span class="sc">{</span>samples<span class="sc">}</span><span class="ss"> axis=</span><span class="sc">{</span>axis<span class="sc">}</span><span class="ss">.pdf"</span>)</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"time"</span>, SBRD_varName<span class="op">=</span><span class="st">"time"</span>, yLabel<span class="op">=</span><span class="va">None</span>, axis<span class="op">=</span><span class="dv">0</span>, mean_1_name<span class="op">=</span><span class="va">None</span>, mean_2_name<span class="op">=</span><span class="va">None</span>, title<span class="op">=</span><span class="va">None</span>, variance<span class="op">=</span><span class="va">True</span>, only_if_conv<span class="op">=</span><span class="va">False</span>, log<span class="op">=</span><span class="va">False</span>, n_cols<span class="op">=</span><span class="dv">1</span>, number_of_plots<span class="op">=-</span><span class="dv">1</span>, binomial<span class="op">=</span><span class="va">False</span>, width <span class="op">=</span> <span class="dv">6</span>, isPositive<span class="op">=</span><span class="va">False</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>, expnr <span class="op">=</span> <span class="st">"3"</span>):</span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a><span class="co">    Plot runtimes of PGD and SBRD algorithms in subplots, comparing them across one parameter.</span></span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a><span class="co">    - PGD_varName, SBRD_varName: variable name suffix for accessing data (e.g., "time" accesses PGD_time and SBRD_time)</span></span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a><span class="co">    - axis: 0 or 1</span></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a><span class="co">        - 0: compare across N for each Lambda (row-wise)</span></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a><span class="co">        - 1: compare across Lambda for each N (column-wise)</span></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a><span class="co">    - variance: whether to include standard deviation shading</span></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a><span class="co">    - only_if_conv: whether to only include data when convergence was achieved (using PGD_isNash, SBRD_isNash)</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a><span class="co">    - log: whether to plot on a log scale</span></span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_cols: number of columns of subplots to create</span></span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a><span class="co">    - lambda_vals: global list/array of Lambda values</span></span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a><span class="co">    - A_vals: global list/array of N values</span></span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a><span class="co">    - number_of_plots: number of subplots to display (equally spaced). If -1, show all.</span></span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a><span class="co">    - binomial: whether the data is binomial (0-1)</span></span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a><span class="co">    - isPositive: whether to clip the lower bound at 0</span></span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> yLabel <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>        yLabel <span class="op">=</span> PGD_varName</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> process_data(alg_name, varName):</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> <span class="bu">globals</span>()[<span class="ss">f"</span><span class="sc">{</span>alg_name<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>varName<span class="sc">}</span><span class="ss">"</span>]</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> only_if_conv:</span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>            isNash <span class="op">=</span> <span class="bu">globals</span>()[<span class="ss">f"</span><span class="sc">{</span>alg_name<span class="sc">}</span><span class="ss">_S</span><span class="sc">{</span>expnr<span class="sc">}</span><span class="ss">_isNash"</span>]</span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> np.where(isNash, data, np.nan)</span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>        mean_data <span class="op">=</span> np.nanmean(data, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>        n_data <span class="op">=</span> np.<span class="bu">sum</span>(<span class="op">~</span>np.isnan(data), axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> variance:</span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mean_data, <span class="va">None</span>, <span class="va">None</span></span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> binomial:</span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>            sum_data <span class="op">=</span> np.nansum(data, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>            lower_bounds <span class="op">=</span> np.zeros_like(mean_data)</span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>            upper_bounds <span class="op">=</span> np.ones_like(mean_data)</span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(mean_data.shape[<span class="dv">0</span>]):</span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(mean_data.shape[<span class="dv">1</span>]):</span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> n_data[i, j] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>                        lower, upper <span class="op">=</span> clopper_pearson_interval(<span class="bu">int</span>(sum_data[i, j]), <span class="bu">int</span>(n_data[i, j]))</span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>                        lower_bounds[i, j] <span class="op">=</span> lower</span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>                        upper_bounds[i, j] <span class="op">=</span> upper</span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mean_data, lower_bounds, upper_bounds</span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a>            SE <span class="op">=</span> np.sqrt(np.nanvar(data, axis<span class="op">=-</span><span class="dv">1</span>) <span class="op">/</span> n_data)</span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>            lower_bounds <span class="op">=</span> mean_data <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> SE</span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>            upper_bounds <span class="op">=</span> mean_data <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> SE</span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mean_data, lower_bounds, upper_bounds</span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a>    PGD_mean, PGD_lower, PGD_upper <span class="op">=</span> process_data(<span class="st">"PGD"</span>, PGD_varName)</span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a>    SBRD_mean, SBRD_lower, SBRD_upper <span class="op">=</span> process_data(<span class="st">"SBRD"</span>, SBRD_varName)</span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>    L, N <span class="op">=</span> PGD_mean.shape</span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> axis <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>        num_plots <span class="op">=</span> L</span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>        x_vals <span class="op">=</span> A_vals</span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a>        y_vals <span class="op">=</span> lambda_vals</span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>        get_slice <span class="op">=</span> <span class="kw">lambda</span> data, i: data[i, :]</span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>        label <span class="op">=</span> <span class="st">"Correlation λ"</span></span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">"Nr. actions"</span></span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> axis <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a>        num_plots <span class="op">=</span> N</span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a>        x_vals <span class="op">=</span> lambda_vals</span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a>        y_vals <span class="op">=</span> A_vals</span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a>        get_slice <span class="op">=</span> <span class="kw">lambda</span> data, i: data[:, i]</span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>        label <span class="op">=</span> <span class="st">"Nr. actions"</span></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">"Correlation λ"</span></span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Axis must be 0 (over Lambda) or 1 (over N)"</span>)</span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> <span class="bu">range</span>(num_plots) <span class="cf">if</span> number_of_plots <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">or</span> number_of_plots <span class="op">&gt;=</span> num_plots <span class="cf">else</span> np.linspace(<span class="dv">0</span>, num_plots <span class="op">-</span> <span class="dv">1</span>, number_of_plots, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a>    n_rows <span class="op">=</span> math.ceil(<span class="bu">len</span>(indices) <span class="op">/</span> n_cols)</span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(n_rows, n_cols, figsize<span class="op">=</span>(width <span class="op">*</span> n_cols, <span class="dv">3</span> <span class="op">*</span> n_rows), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a>    axes <span class="op">=</span> np.array(axes).flatten()</span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> {<span class="st">"PGD"</span>: (<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span>), <span class="st">"SBRD"</span>: (<span class="fl">0.9</span>, <span class="fl">0.4</span>, <span class="fl">0.2</span>)}</span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, idx <span class="kw">in</span> <span class="bu">enumerate</span>(indices):</span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[i]</span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a>        ax.set_xlabel(xlabel)</span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> log:</span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a>            ax.set_yscale(<span class="st">'log'</span>)</span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> name, mean, lower, upper, color <span class="kw">in</span> [</span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a>            (<span class="st">"PGD"</span>, PGD_mean, PGD_lower, PGD_upper, colors[<span class="st">"PGD"</span>]),</span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a>            (<span class="st">"SBRD"</span>, SBRD_mean, SBRD_lower, SBRD_upper, colors[<span class="st">"SBRD"</span>])</span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a>        ]:</span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> get_slice(mean, idx)</span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> variance:</span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> binomial:</span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> name <span class="op">==</span> <span class="st">"PGD"</span>:</span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a>                        curr_label <span class="op">=</span> mean_1_name</span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> name <span class="op">==</span> <span class="st">"SBRD"</span>:</span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a>                        curr_label <span class="op">=</span> mean_2_name</span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> name <span class="op">==</span> <span class="st">"PGD"</span>:</span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a>                        curr_label <span class="op">=</span> mean_1_name</span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> name <span class="op">==</span> <span class="st">"SBRD"</span>:</span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a>                        curr_label <span class="op">=</span> mean_2_name</span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a>            ax.plot(x_vals, y, label<span class="op">=</span>curr_label, color<span class="op">=</span>color)</span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> variance <span class="kw">and</span> lower <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> upper <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a>                y_lower <span class="op">=</span> get_slice(lower, idx)</span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a>                y_upper <span class="op">=</span> get_slice(upper, idx)</span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> isPositive:</span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a>                    y_lower <span class="op">=</span> np.clip(y_lower, <span class="dv">0</span>, <span class="va">None</span>)</span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a>                    y_upper <span class="op">=</span> np.clip(y_upper, <span class="dv">0</span>, <span class="va">None</span>)</span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a>                <span class="co">#label_ci = "99.5% CI" if binomial else "±2SE"</span></span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a>                ax.fill_between(x_vals, y_lower, y_upper, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.2</span>)<span class="co">#, label=f"{label_ci}")</span></span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a>        ax.set_ylabel(yLabel)</span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> title <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a>            ax.set_title(<span class="ss">f"</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span><span class="bu">round</span>(y_vals[idx], <span class="dv">2</span>)<span class="sc">}</span><span class="ss">, samples = </span><span class="sc">{</span>samples<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a>            ax.set_title(title)</span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a>        ax.legend(loc<span class="op">=</span> legend_loc)</span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a>        ax.grid(<span class="va">True</span>)</span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(indices), <span class="bu">len</span>(axes)):</span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a>        fig.delaxes(axes[j])</span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout(rect<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.96</span>])</span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="ss">f"compare_</span><span class="sc">{</span>PGD_varName<span class="sc">}</span><span class="ss">_axis=</span><span class="sc">{</span>axis<span class="sc">}</span><span class="ss">.pdf"</span>)</span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="dynamics-definitions" class="level2">
<h2 class="anchored" data-anchor-id="dynamics-definitions">Dynamics definitions</h2>
<div id="5659e466" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_reward_matrix(P, A, lam):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Generate the reward matrix for an P-player A-actions game </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - N (int): Number of actions per player.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">    - lam (float): Correlation between players' payoffs.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - np.ndarray: Reward tensor G of shape (3, N, N, N). Each entry G[i, a, b, c]</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">      is the payoff for player i when players 1, 2, 3 play actions a, b, c respectively.</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Correlation matrix across players</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    diagonal <span class="op">=</span> np.diag(np.ones(P))</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    ones_matrix <span class="op">=</span> np.ones((P, P))</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    corr_matrix <span class="op">=</span> (ones_matrix<span class="op">-</span>np.diag(np.diag(ones_matrix)))<span class="op">*</span>lam<span class="op">+</span>diagonal</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cholesky decomposition for generating correlated normal variables</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> np.linalg.cholesky(corr_matrix)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate correlated payoffs for all joint action profiles</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    raw_samples <span class="op">=</span> np.random.randn(P, A<span class="op">**</span>P)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    correlated <span class="op">=</span> L <span class="op">@</span> raw_samples</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    shape <span class="op">=</span> <span class="bu">tuple</span>(P <span class="cf">if</span> i<span class="op">==</span><span class="dv">0</span> <span class="cf">else</span> A <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reshape to (3, N, N, N): one payoff matrix per player</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> correlated.reshape(shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="98c3908b-da68-45d9-a3c6-49a95a4cc537" class="cell" data-jupyter="{&quot;source_hidden&quot;:true}" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> best_response_dynamics(G, A<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Simulate Best Response Dynamics (SBRD) in a 3-player game.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - G (np.ndarray): Reward tensor of shape (3, N, N, N). G[i, a, b, c] gives the payoff</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">      to player i when players 0, 1, 2 choose actions a, b, c respectively.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - cycle_length (int): Length of the cycle detected by SBRD.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - total_steps (int): Total number of steps before entering the cycle.</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - final_payoff (float): Average payoff for player 0 over the detected cycle.</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> G.shape[<span class="dv">0</span>]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> A <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> G.shape[<span class="dv">1</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="bu">tuple</span>(<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(P))        <span class="co"># Initial strategy profile</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">0</span>                             <span class="co"># Step counter</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    history <span class="op">=</span> <span class="bu">dict</span>()                      <span class="co"># Maps strategy profiles to step indices</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Best responses given others' actions</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="bu">tuple</span>( np.argmax( G[ <span class="bu">tuple</span>(i <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> x[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">if</span> j<span class="op">-</span><span class="dv">1</span> <span class="op">!=</span> i <span class="cf">else</span> <span class="bu">slice</span>(<span class="dv">0</span>, A) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(P<span class="op">+</span><span class="dv">1</span>)) ] ) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="kw">in</span> history:</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            cycle_length <span class="op">=</span> index <span class="op">-</span> history[x]</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cycle_length <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Nash Equilibria</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> cycle_length, index, G[<span class="bu">tuple</span>(<span class="dv">0</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> x[i<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P<span class="op">+</span><span class="dv">1</span>))]</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>            <span class="co"># General cycle detected: compute average payoff for player 0</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            cycle <span class="op">=</span> [x]</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            avg <span class="op">=</span> G[<span class="bu">tuple</span>(<span class="dv">0</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> x[i<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P<span class="op">+</span><span class="dv">1</span>))]</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(cycle_length <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>                x <span class="op">=</span> <span class="bu">tuple</span>( np.argmax( G[ <span class="bu">tuple</span>(i <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> x[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">if</span> j<span class="op">-</span><span class="dv">1</span> <span class="op">!=</span> i <span class="cf">else</span> <span class="bu">slice</span>(<span class="dv">0</span>, A) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(P<span class="op">+</span><span class="dv">1</span>)) ] ) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>                cycle.append(x)</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>                avg <span class="op">+=</span> G[<span class="bu">tuple</span>(<span class="dv">0</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> x[i<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P<span class="op">+</span><span class="dv">1</span>))]</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> cycle_length, index, avg <span class="op">/</span> cycle_length</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Log the current profile and continue</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>        history[x] <span class="op">=</span> index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="64783d88" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> softmax(r):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a softmax function.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    exp_r <span class="op">=</span> np.exp(r <span class="op">-</span> np.<span class="bu">max</span>(r))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp_r <span class="op">/</span> np.<span class="bu">sum</span>(exp_r)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="974f9633" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> new_SPGD(G, eta<span class="op">=</span><span class="fl">1.0</span>, max_iter<span class="op">=</span><span class="dv">50_000</span>, T_max<span class="op">=</span><span class="dv">10</span>): </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># The following function implements a (softmax) gradient ascent algorithm for a 3-player game with n actions.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># It takes the number of actions n, a correlation parameter lam, a learning rate eta, a max iteration count,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># and a tolerance for convergence as inputs. It returns the average payoff, the number of iterations,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># and the final payoff for player 0.    </span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    t_0 <span class="op">=</span> time()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialise each player's "logit" vector (which will be mapped to a mixed strategy via softmax).</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    P, A <span class="op">=</span> G.shape[<span class="dv">0</span>:<span class="dv">2</span>]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> <span class="bu">tuple</span>(np.zeros(A) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    total_payoff <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>A</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    p<span class="op">=</span>[<span class="dv">3</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P)]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert logits to mixed strategies.</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        Softmax <span class="op">=</span> <span class="bu">tuple</span>(softmax(R[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute the expected payoff for each pure action for each player.</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For player 0: Q0[i] = sum_{j,k} p1[j] p2[k] G[0][i, j, k]</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        Q <span class="op">=</span> <span class="bu">tuple</span>(                       <span class="co"># Q[0], …, Q[P-1]</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            np.array([               <span class="co">#   each is an (A, …, A) tensor</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>                np.take(G[p], i, axis<span class="op">=</span>p)              <span class="co"># fix the i-th action of player p</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">@</span> <span class="bu">reduce</span>(matmul,                     <span class="co"># multiply all the other Softmax mats</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>                        (Softmax[j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(P) <span class="cf">if</span> j <span class="op">!=</span> p))</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(A)])</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> p <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For player 1: Q1[i] = sum_{j,k} p0[j] p2[k] G[1][j, i, k]</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute the overall expected payoff for each player.</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        F <span class="op">=</span> <span class="bu">tuple</span>(np.dot(Softmax[i], Q[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Accumulate payoff for averaging.</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>        total_payoff <span class="op">+=</span> F[<span class="dv">0</span>]</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Every 100 iterations, check if the current strategy profile is an epsilon-NE.</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it <span class="op">%</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> <span class="bu">tuple</span>(np.<span class="bu">max</span>(Q[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="bu">min</span>(best)<span class="op">&gt;</span><span class="fl">0.99</span>) <span class="kw">or</span> (time()<span class="op">-</span>t_0 <span class="op">&gt;</span> T_max):</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        grad <span class="op">=</span> <span class="bu">tuple</span>(Q[i]<span class="op">-</span>F[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the logits using a simple gradient ascent step.</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>        R <span class="op">=</span> <span class="bu">tuple</span>(R[i]<span class="op">+</span>eta<span class="op">*</span>grad[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(P))</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    avg_payoff <span class="op">=</span> total_payoff <span class="op">/</span> it</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> it, avg_payoff, F[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="main-results" class="level1">
<h1>Main Results</h1>
<section id="section-1.-finding-2-player-random-potential-games-converge-fast-to-a-two-cycle" class="level2">
<h2 class="anchored" data-anchor-id="section-1.-finding-2-player-random-potential-games-converge-fast-to-a-two-cycle">Section 1. Finding: 2-player random potential games converge fast to a two-cycle</h2>
<p>Setting of the experiment: - 10000 independent simulations - Each simulation takes lambda in a range of values between 0 and 1 - The number of actions is set to 50 - The number of players is set to two</p>
<p>Statistics analysed: - SBRD_S1_twoCycles[l, 0, t]: True if the t-th test with the l-th value of lambda converges to a 2-cycle - SBRD_S1_nrSteps[l, 0, t]: number of steps to convergence (or cycle) of the t-th test with the l-th value of lambda</p>
<div id="d16f302c-569f-43b7-960a-c0516c082b7a" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of simulations per (λ, N) setting</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">10_000</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>lambda_vals <span class="op">=</span> [<span class="fl">0.09999999999</span><span class="op">*</span><span class="fl">0.5</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">21</span>)]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>A_vals <span class="op">=</span> [<span class="dv">50</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>SBRD_S1_twoCycles <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="dv">1</span>, samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>SBRD_S1_nrSteps <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now run the experiment, setting the numpy random seed to 2025. We print the time it takes to run the whole experiment in seconds.</p>
<div id="9c27a533" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">2025</span>) <span class="co">#We set the random seed for reproducibility </span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>T_0 <span class="op">=</span> time()  <span class="co"># Start timer for entire experiment</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>max_A <span class="op">=</span> <span class="bu">max</span>(A_vals)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count_lam, lam <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_vals):  <span class="co"># Loop over each lambda value</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(samples):  <span class="co"># Repeat experiment for statistical robustness</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> generate_reward_matrix(<span class="dv">2</span>, max_A, lam)  <span class="co"># Generate a payoff matrix with max_n actions and correlation lambda</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> count_A, A <span class="kw">in</span> <span class="bu">enumerate</span>(A_vals):  <span class="co"># Now restrict to smaller N if needed</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Run Best Response Dynamics and time it</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            SBRD_len, SBRD_it, SBRD_val_curr <span class="op">=</span> best_response_dynamics(G, A)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            SBRD_S1_twoCycles[count_lam, count_A, i] <span class="op">=</span> (SBRD_len <span class="op">==</span> <span class="dv">2</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            SBRD_S1_nrSteps[count_lam, count_A, i] <span class="op">=</span> SBRD_it</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Final time report</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>Total_time <span class="op">=</span> time() <span class="op">-</span> T_0</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Total_time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>23.52963089942932</code></pre>
</div>
</div>
<p>We now begin to plot our results. The first plot represents the probability of SBRD to converge to a 2-cycle. It is plotted with a 99.5% Clopper-Pearson CI.</p>
<div id="9d5885ac" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S1_twoCycles"</span>, title<span class="op">=</span><span class="st">""</span>, mean_name<span class="op">=</span><span class="st">"Prob"</span>, ylabel<span class="op">=</span><span class="st">"Prob. conver. to two-cycle"</span>, axis<span class="op">=</span><span class="dv">1</span>, binomial<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-11-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The second plot represents the average number of steps before convergence. It is plotted with a 2SE interval around the mean.</p>
<div id="24813df6" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S1_nrSteps"</span>, mean_name<span class="op">=</span><span class="st">"nrSteps"</span>, title<span class="op">=</span><span class="st">""</span>, ylabel<span class="op">=</span><span class="st">"Steps"</span>, axis<span class="op">=</span><span class="dv">1</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">False</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>With the following script, we investigate the thresholds of lambda for which the probability of SBRD to converge to a 2-cycle surpasses 50% and 90% respectively. Which is, we find that if lambda is at least 0.55, then the probability of SBRD to converge to a 2-cycle is at least 50%. If lambda is at least 0.9, the probability is at least 90%.</p>
<div id="c84b7566" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">round</span>(lambda_vals[<span class="bu">int</span>(np.argmax(np.mean(SBRD_S1_twoCycles, axis<span class="op">=-</span><span class="dv">1</span>)<span class="op">&gt;</span><span class="fl">0.5</span>))],<span class="dv">2</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">round</span>(lambda_vals[<span class="bu">int</span>(np.argmax(np.mean(SBRD_S1_twoCycles, axis<span class="op">=-</span><span class="dv">1</span>)<span class="op">&gt;</span><span class="fl">0.9</span>))],<span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.55
0.9</code></pre>
</div>
</div>
</section>
<section id="section-2.-finding-3-player-random-potential-games-converge-fast-to-a-ne" class="level2">
<h2 class="anchored" data-anchor-id="section-2.-finding-3-player-random-potential-games-converge-fast-to-a-ne">Section 2. Finding: 3-player random potential games converge fast to a NE</h2>
<p>We now consider the setting with three players. Setting of the experiment: - 10000 independent simulations - Each simulation takes lambda in a range of values between 0 and 1 - The number of actions is set to 50 - The number of players is set to three</p>
<p>Statistics analysed: - SBRD_S2_isNash[l, 0, t]: True if the t-th test with the l-th value of lambda converges to a NE - SBRD_S2_nrSteps[l, 0, t]: number of steps to convergence (or cycle) of the t-th test with the l-th value of lambda</p>
<div id="55ca9d45" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of simulations per (λ, N) setting</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">10_000</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>lambda_vals <span class="op">=</span> [<span class="fl">0.09999999999</span><span class="op">*</span><span class="fl">0.5</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">21</span>)]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>A_vals <span class="op">=</span> [<span class="dv">50</span>]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>SBRD_S2_isNash <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="dv">1</span>, samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>SBRD_S2_nrSteps <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now run the experiment, setting the numpy random seed to 2025. We print the time it takes to run the whole experiment in seconds.</p>
<div id="2879eb3a" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">2025</span>) <span class="co">#We set the random seed for reproducibility </span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>T_0 <span class="op">=</span> time()  <span class="co"># Start timer for entire experiment</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>max_A <span class="op">=</span> <span class="bu">max</span>(A_vals)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count_lam, lam <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_vals):  <span class="co"># Loop over each lambda value</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(samples):  <span class="co"># Repeat experiment for statistical robustness</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> generate_reward_matrix(<span class="dv">3</span>, max_A, lam)  <span class="co"># Generate a payoff matrix with max_n actions and correlation lambda</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> count_A, A <span class="kw">in</span> <span class="bu">enumerate</span>(A_vals):  <span class="co"># Now restrict to smaller N if needed</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Run Best Response Dynamics and time it</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>            SBRD_len, SBRD_it, SBRD_val_curr <span class="op">=</span> best_response_dynamics(G, A)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            SBRD_S2_isNash[count_lam, count_A, i] <span class="op">=</span> (SBRD_len <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            SBRD_S2_nrSteps[count_lam, count_A, i] <span class="op">=</span> SBRD_it</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Final time report</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>Total_time <span class="op">=</span> time() <span class="op">-</span> T_0</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Total_time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1237.7669422626495</code></pre>
</div>
</div>
<p>We are now ready to plot our results. We first plot the probability of SBRD to converge to a NE. We plot a 99.5% Clopper-Pearson CI</p>
<div id="ab942410" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S2_isNash"</span>, title<span class="op">=</span><span class="st">""</span>, mean_name<span class="op">=</span><span class="st">"isNash"</span>, ylabel<span class="op">=</span><span class="st">"Prob. conver. to NE"</span>, axis<span class="op">=</span><span class="dv">1</span>, binomial<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-16-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>And then the expected number of steps before convergence (or reaching a cycle). We add a 2SE interval to the plot.</p>
<div id="c2621eed" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S2_nrSteps"</span>, mean_name<span class="op">=</span><span class="st">"nrSteps"</span>, title<span class="op">=</span><span class="st">""</span>, ylabel<span class="op">=</span><span class="st">"Steps"</span>, axis<span class="op">=</span><span class="dv">1</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">False</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="section-3.-finding-comparison-of-sbrd-and-spgd-in-3-player-random-potential-games" class="level2">
<h2 class="anchored" data-anchor-id="section-3.-finding-comparison-of-sbrd-and-spgd-in-3-player-random-potential-games">Section 3. Finding: comparison of SBRD and SPGD in 3-player random potential games</h2>
<p>We now compare SBRD with SPGD for 3-player games. Setting of the experiment: - 1000 independent simulations - Each simulation takes lambda in a range of values between 0.85 and 1 - The number of actions is set to 50 - The number of players is set to three</p>
<p>Statistics analysed: - For SPGD: - PGD_S3_isNash[l, 0, t]: True if for the t-th test with the l-th value of lambda, SPGD converges to a NE - PGD_S3_numIte[l, 0, t]: number of steps to convergence (or cycle) for SPGD of the t-th test with the l-th value of lambda - PGD_S3_valFin[l, 0, t]: final payoff reached by SBPD in the t-th test with l-th value of lambda - PGD_S3_valAvg[l, 0, t]: average payoff during the trajectory of SBPD in the t-th test with the l-th value of lambda - PGD_S3_time[l, 0, t]: time to run SBPD in the t-th test with l-th value of lambda. - Remark: SPGD is automatically stopped at the first check-point after 10 seconds run. - for SBRD: - SBRD_S3_isNash[l, 0, t]: True if for the t-th test with the l-th value of lambda, SBRD converges to a NE - SBRD_S3_numIte[l, 0, t]: number of steps to convergence (or cycle) for SBRD of the t-th test with the l-th value of lambda - SBRD_S3_val[l, 0, t]: NE payoff reached by SBRD in the t-th test with l-th value of lambda if SBRD converges to a NE, or average payoff along the cycle if SBRD converges to a cycle. - SBRD_S3_time[l, 0, t]: time to run SBRD in the t-th test with l-th value of lambda.</p>
<div id="6f425416" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Experimental setup</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>lambda_vals <span class="op">=</span> [<span class="fl">0.85</span><span class="op">+</span><span class="fl">0.09999999999</span><span class="op">*</span><span class="fl">0.25</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">7</span>)] <span class="co"># List of lambda values to test</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>A_vals <span class="op">=</span> [<span class="dv">50</span>]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Outputs to Track</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Policy Gradient Dynamics</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>PGD_S3_isNash <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>) <span class="co"># {0,1} veridicity of Nash in Policy Gradient Dynamics</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>PGD_S3_numIte <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Number of iterations in Policy Gradient Dynamics</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>PGD_S3_valFin <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Final payoff for player 0 in Policy Gradient Dynamics</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>PGD_S3_valAvg <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Average payoff for player 0 in Policy Gradient Dynamics</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>PGD_S3_time <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))   <span class="co"># Runtime in Policy Gradient Dynamics</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co">## Best Response Dynamics</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>SBRD_S3_isNash <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>) <span class="co"># {0,1} veridicity of Nash in Best Response Dynamics</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>SBRD_S3_numIte <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Number of iterations in Best Response Dynamics</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>SBRD_S3_val <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Final payoff for player 0 in Best Response Dynamics</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>SBRD_S3_time <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))   <span class="co"># Runtime in Best Response Dynamics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1582ee88" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>max_A <span class="op">=</span> A_vals[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Maximum number of actions (fixed at 50)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">2025</span>) <span class="co">#We set the random seed for reproducibility </span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>T_0 <span class="op">=</span> time()  <span class="co"># Start the global timer</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count_lam, lam <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_vals):  <span class="co"># Loop over correlation values</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(samples):  <span class="co"># Loop over sample repetitions</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate a shared reward matrix for both algorithms</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> generate_reward_matrix(<span class="dv">3</span>, max_A, lam)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> count_A, A <span class="kw">in</span> <span class="bu">enumerate</span>(A_vals):  <span class="co"># Loop over population sizes (fixed here)</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>            t_0 <span class="op">=</span> time()  <span class="co"># Start timer for PGD</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>            PGD_it, PGD_avg_val, PGD_val <span class="op">=</span> gradient_ascent_dynamics(G, A)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> time() <span class="op">-</span> t_0  <span class="co"># Elapsed time</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            PGD_S3_isNash[count_lam, count_A, i] <span class="op">=</span> (PGD_it <span class="op">&lt;</span> <span class="dv">50_000</span> <span class="op">-</span> <span class="dv">1</span>)  <span class="co"># Converged?</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            PGD_S3_numIte[count_lam, count_A, i] <span class="op">=</span> PGD_it</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            PGD_S3_valFin[count_lam, count_A, i] <span class="op">=</span> PGD_val</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>            PGD_S3_valAvg[count_lam, count_A, i] <span class="op">=</span> PGD_avg_val</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>            PGD_S3_time[count_lam, count_A, i] <span class="op">=</span> t</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># === Best Response Dynamics (SBRD) ===</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>            t_0 <span class="op">=</span> time()  <span class="co"># Start timer for SBRD</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>            SBRD_len, SBRD_it, SBRD_val_curr <span class="op">=</span> best_response_dynamics(G, A)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> time() <span class="op">-</span> t_0  <span class="co"># Elapsed time</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Store SBRD results</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>            SBRD_S3_isNash[count_lam, count_A, i] <span class="op">=</span> (SBRD_len <span class="op">==</span> <span class="dv">1</span>)  <span class="co"># Converged to pure NE?</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>            SBRD_S3_numIte[count_lam, count_A, i] <span class="op">=</span> SBRD_it</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>            SBRD_S3_val[count_lam, count_A, i] <span class="op">=</span> SBRD_val_curr</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>            SBRD_S3_time[count_lam, count_A, i] <span class="op">=</span> t</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a><span class="co"># === Time Summary ===</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>Tot_time <span class="op">=</span> time() <span class="op">-</span> T_0</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>Tot_time_SBRD <span class="op">=</span> np.<span class="bu">sum</span>(SBRD_S3_time)</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>Tot_time_PGD <span class="op">=</span> np.<span class="bu">sum</span>(PGD_S3_time)</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>Tot_time_gener <span class="op">=</span> Tot_time <span class="op">-</span> Tot_time_SBRD <span class="op">-</span> Tot_time_PGD</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Print runtime breakdown</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total time to run: </span><span class="sc">{</span><span class="bu">round</span>(Tot_time, <span class="dv">1</span>)<span class="sc">}</span><span class="ss"> s"</span>)</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentage of the time spent on random generation of matrix: </span><span class="sc">{</span><span class="bu">round</span>((Tot_time_gener <span class="op">/</span> Tot_time) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">1</span>)<span class="sc">}</span><span class="ss">%"</span>)</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentage of the time spent on SBRD algorithm: </span><span class="sc">{</span><span class="bu">round</span>((Tot_time_SBRD <span class="op">/</span> Tot_time) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">1</span>)<span class="sc">}</span><span class="ss">%"</span>)</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentage of the time spent on PGD algorithm: </span><span class="sc">{</span><span class="bu">round</span>((Tot_time_PGD <span class="op">/</span> Tot_time) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">1</span>)<span class="sc">}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total time to run: 5859.2 s
Percentage of the time spent on random generation of matrix: 0.6%
Percentage of the time spent on SBRD algorithm: 0.0%
Percentage of the time spent on PGD algorithm: 99.4%</code></pre>
</div>
</div>
<p>Additional remark: We print what percentage of the time each part of the experiment takes. We consistently obtain that SPGD counts for over 99% of the whole time, SBRD accounts for less than 0.1% of the running time.</p>
<p>We are now ready to plot our findings. We first compare the average running time of both algorithms. Note that SPGD is stopped at the first checkpoint after 10 seconds. Further notice that the scale used is logarithmic!</p>
<div id="022bce4b" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S3_time"</span>, SBRD_varName<span class="op">=</span><span class="st">"S3_time"</span>, title<span class="op">=</span><span class="st">""</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Seconds"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">True</span>, expnr<span class="op">=</span><span class="st">"3"</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-20-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We now compare the final payoffs of the two algorithms. As the plotting function is called with parameter `only_if_conv=True’, we only consider the cases in which both algorithms converge. Notice that this happens with probability at least 90% at these regimes of lambda for both algorithms, as analysed above.</p>
<div id="26a368a7" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S3_valFin"</span>, SBRD_varName<span class="op">=</span><span class="st">"S3_val"</span>, title<span class="op">=</span><span class="st">""</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>, expnr<span class="op">=</span><span class="st">"3"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Value"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, only_if_conv<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-21-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We compare now the number of steps required to converge (to a NE or a cycle) for both algorithms. The scale is again logarithmic.</p>
<div id="0de63d70" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S3_numIte"</span>, SBRD_varName<span class="op">=</span><span class="st">"S3_numIte"</span>, title<span class="op">=</span><span class="st">""</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Steps"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-22-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We finally compare, over all the experiments (both converging and not), the average payoff of SPGD along its learning curve with the final payoff of SBRD. As described in the main paper, this makes sense as the number of steps to convergence of SBRD is much lower than the number of steps to convergence of SPGD.</p>
<div id="91812bd7" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S3_valAvg"</span>, SBRD_varName<span class="op">=</span><span class="st">"S3_val"</span>, title<span class="op">=</span><span class="st">""</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Value"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-23-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="appendix" class="level1">
<h1>Appendix</h1>
<section id="section-a.-results-of-section-1.-also-hold-for-more-actions" class="level2">
<h2 class="anchored" data-anchor-id="section-a.-results-of-section-1.-also-hold-for-more-actions">Section A. Results of Section 1. also hold for more actions</h2>
<p>We now show that what we showed in Section 1. still holds for more actions. Setting of the experiment: - 1000 independent simulations - Each simulation takes lambda in a range of values between 0 and 1 - The number of actions is set to 500 - The number of players is set to two</p>
<p>Statistics analysed: - SBRD_S4_twoCycles[l, 0, t]: True if the t-th test with the l-th value of lambda converges to a 2-cycle - SBRD_S4_nrSteps[l, 0, t]: number of steps to convergence (or cycle) of the t-th test with the l-th value of lambda</p>
<div id="9f22fd88" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of simulations per (λ, N) setting</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">1_000</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>lambda_vals <span class="op">=</span> [<span class="fl">0.09999999999</span><span class="op">*</span><span class="fl">0.5</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">21</span>)]</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>A_vals <span class="op">=</span> [<span class="dv">500</span>]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>SBRD_S4_twoCycles <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="dv">1</span>, samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>SBRD_S4_nrSteps <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e6379472" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">2025</span>) <span class="co">#We set the random seed for reproducibility </span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>T_0 <span class="op">=</span> time()  <span class="co"># Start timer for entire experiment</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>max_A <span class="op">=</span> <span class="bu">max</span>(A_vals)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count_lam, lam <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_vals):  <span class="co"># Loop over each lambda value</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(samples):  <span class="co"># Repeat experiment for statistical robustness</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> generate_reward_matrix(<span class="dv">2</span>, max_A, lam)  <span class="co"># Generate a payoff matrix with max_n actions and correlation lambda</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> count_A, A <span class="kw">in</span> <span class="bu">enumerate</span>(A_vals):  <span class="co"># Now restrict to smaller N if needed</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Run Best Response Dynamics and time it</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>            SBRD_len, SBRD_it, SBRD_val_curr <span class="op">=</span> best_response_dynamics(G, A)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>            SBRD_S4_twoCycles[count_lam, count_A, i] <span class="op">=</span> (SBRD_len <span class="op">==</span> <span class="dv">2</span>)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>            SBRD_S4_nrSteps[count_lam, count_A, i] <span class="op">=</span> SBRD_it</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Final time report</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>Total_time <span class="op">=</span> time() <span class="op">-</span> T_0</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Total_time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>126.69464802742004</code></pre>
</div>
</div>
<p>Exactly as before, we plot the probability of SBRD to converge to a two-cycle (with 99.5% Clopper-Pearson CI)</p>
<div id="1057be00" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S4_twoCycles"</span>, title<span class="op">=</span><span class="st">""</span>, mean_name<span class="op">=</span><span class="st">"twoCycle"</span>, ylabel<span class="op">=</span><span class="st">"Prob. conver. to two-cycle"</span>, axis<span class="op">=</span><span class="dv">1</span>, binomial<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-26-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>And now the number of steps to convergence, with a 2SE range.</p>
<div id="291dcab2" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S4_nrSteps"</span>, mean_name<span class="op">=</span><span class="st">"nrSteps"</span>, title<span class="op">=</span><span class="st">""</span>, ylabel<span class="op">=</span><span class="st">"Steps"</span>, axis<span class="op">=</span><span class="dv">1</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">False</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-27-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>And, as before, the threshold values of lambda. Notice that now SBRD converges to a two-cycle with 90% probability for all the values of lambda over 0.75.</p>
<div id="50b7ed26" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">round</span>(lambda_vals[<span class="bu">int</span>(np.argmax(np.mean(SBRD_S4_twoCycles, axis<span class="op">=-</span><span class="dv">1</span>)<span class="op">&gt;</span><span class="fl">0.5</span>))],<span class="dv">2</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">round</span>(lambda_vals[<span class="bu">int</span>(np.argmax(np.mean(SBRD_S4_twoCycles, axis<span class="op">=-</span><span class="dv">1</span>)<span class="op">&gt;</span><span class="fl">0.9</span>))],<span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.5
0.75</code></pre>
</div>
</div>
</section>
<section id="section-b.1.-results-of-section-2.-also-hold-for-more-actions" class="level2">
<h2 class="anchored" data-anchor-id="section-b.1.-results-of-section-2.-also-hold-for-more-actions">Section B.1. Results of Section 2. also hold for more actions</h2>
<p>We now show that what we showed in Section 1. still holds for more actions. Setting of the experiment: - 1000 independent simulations - Each simulation takes lambda in a range of values between 0 and 1 - The number of actions is set to 100 - The number of players is set to three</p>
<p>Statistics analysed: - SBRD_S5_isNash[l, 0, t]: True if the t-th test with the l-th value of lambda converges to a NE - SBRD_S5_nrSteps[l, 0, t]: number of steps to convergence (or cycle) of the t-th test with the l-th value of lambda</p>
<div id="ca2812e2" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of simulations per (λ, N) setting</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>lambda_vals <span class="op">=</span> [<span class="fl">0.09999999999</span><span class="op">*</span><span class="fl">0.5</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">21</span>)]</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>A_vals <span class="op">=</span> [<span class="dv">100</span>]</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>SBRD_S5_isNash <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="dv">1</span>, samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>SBRD_S5_nrSteps <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="c3b4a0fc" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">2025</span>) <span class="co">#We set the random seed for reproducibility </span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>T_0 <span class="op">=</span> time()  <span class="co"># Start timer for entire experiment</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>max_A <span class="op">=</span> <span class="bu">max</span>(A_vals)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count_lam, lam <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_vals):  <span class="co"># Loop over each lambda value</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(samples):  <span class="co"># Repeat experiment for statistical robustness</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> generate_reward_matrix(<span class="dv">3</span>, max_A, lam)  <span class="co"># Generate a payoff matrix with max_n actions and correlation lambda</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> count_A, A <span class="kw">in</span> <span class="bu">enumerate</span>(A_vals):  <span class="co"># Now restrict to smaller N if needed</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Run Best Response Dynamics and time it</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>            SBRD_len, SBRD_it, SBRD_val_curr <span class="op">=</span> best_response_dynamics(G, A)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>            SBRD_S5_isNash[count_lam, count_A, i] <span class="op">=</span> (SBRD_len <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>            SBRD_S5_nrSteps[count_lam, count_A, i] <span class="op">=</span> SBRD_it</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Final time report</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>Total_time <span class="op">=</span> time() <span class="op">-</span> T_0</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Total_time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>853.8707270622253</code></pre>
</div>
</div>
<p>As before, we print the probability of SBRD to converge to a NE</p>
<div id="1c106cf4" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S5_isNash"</span>, title<span class="op">=</span><span class="st">""</span>, mean_name<span class="op">=</span><span class="st">"isNash"</span>, ylabel<span class="op">=</span><span class="st">"Prob. conver. to NE"</span>, axis<span class="op">=</span><span class="dv">1</span>, binomial<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-31-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>And then the average number of steps to convergence</p>
<div id="6cbed524" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S5_nrSteps"</span>, mean_name<span class="op">=</span><span class="st">"nrSteps"</span>, title<span class="op">=</span><span class="st">""</span>, ylabel<span class="op">=</span><span class="st">"Steps"</span>, axis<span class="op">=</span><span class="dv">1</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">False</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-32-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="section-b.2.-results-of-section-2.-also-hold-for-more-players" class="level2">
<h2 class="anchored" data-anchor-id="section-b.2.-results-of-section-2.-also-hold-for-more-players">Section B.2. Results of Section 2. also hold for more players</h2>
<p>We now test SBRD for 4 players. Setting of the experiment: - 1000 independent simulations - Each simulation takes lambda in a range of values between 0 and 1 - The number of actions is set to 50 - The number of players is set to four</p>
<p>Statistics analysed: - SBRD_S6_isNash[l, 0, t]: True if the t-th test with the l-th value of lambda converges to a NE - SBRD_S6_nrSteps[l, 0, t]: number of steps to convergence (or cycle) of the t-th test with the l-th value of lambda</p>
<div id="88ae7fcc" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of simulations per (λ, N) setting</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">1_000</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>lambda_vals <span class="op">=</span> [<span class="fl">0.09999999999</span><span class="op">*</span><span class="fl">0.5</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">21</span>)]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>A_vals <span class="op">=</span> [<span class="dv">50</span>]</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>SBRD_S6_isNash <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="dv">1</span>, samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>SBRD_S6_nrSteps <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b443668f" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">2025</span>) <span class="co">#We set the random seed for reproducibility </span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>T_0 <span class="op">=</span> time()  <span class="co"># Start timer for entire experiment</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>max_A <span class="op">=</span> <span class="bu">max</span>(A_vals)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count_lam, lam <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_vals):  <span class="co"># Loop over each lambda value</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(samples):  <span class="co"># Repeat experiment for statistical robustness</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> generate_reward_matrix(<span class="dv">4</span>, max_A, lam)  <span class="co"># Generate a payoff matrix with max_n actions and correlation lambda</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> count_A, A <span class="kw">in</span> <span class="bu">enumerate</span>(A_vals):  <span class="co"># Now restrict to smaller N if needed</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Run Best Response Dynamics and time it</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>            SBRD_len, SBRD_it, SBRD_val_curr <span class="op">=</span> best_response_dynamics(G, A)</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>            SBRD_S6_isNash[count_lam, count_A, i] <span class="op">=</span> (SBRD_len <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>            SBRD_S6_nrSteps[count_lam, count_A, i] <span class="op">=</span> SBRD_it</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Final time report</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>Total_time <span class="op">=</span> time() <span class="op">-</span> T_0</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Total_time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>25260.329627752304</code></pre>
</div>
</div>
<p>We see that the probability of convergence to a NE follows the same pattern as above. We plot, as before, a confidence interval of 99.5% Clopper-Pearson.</p>
<div id="b6fa2d1a" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S6_isNash"</span>, title<span class="op">=</span><span class="st">""</span>, mean_name<span class="op">=</span><span class="st">"isNash"</span>, ylabel<span class="op">=</span><span class="st">"Prob. conver. to NE"</span>, axis<span class="op">=</span><span class="dv">1</span>, binomial<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-35-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We also plot the average number of steps taken to convergence</p>
<div id="e934874d" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>plot_single_algorithm(alg_name<span class="op">=</span><span class="st">"SBRD"</span>, varName<span class="op">=</span><span class="st">"S6_nrSteps"</span>, mean_name<span class="op">=</span><span class="st">"nrSteps"</span>, title<span class="op">=</span><span class="st">""</span>, ylabel<span class="op">=</span><span class="st">"Steps"</span>, axis<span class="op">=</span><span class="dv">1</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">False</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-36-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="section-c.1.-results-of-section-3.-also-hold-for-more-actions" class="level2">
<h2 class="anchored" data-anchor-id="section-c.1.-results-of-section-3.-also-hold-for-more-actions">Section C.1. Results of Section 3. also hold for more actions</h2>
<p>Finally, we compare SBRD and SPGD over more actions to show that the behaviour is similar. Setting of the experiment: - 1000 independent simulations - Each simulation takes lambda in a range of values between 0.85 and 1 - The number of actions is set to 100 - The number of players is set to three</p>
<p>Statistics analysed: - For SPGD: - PGD_S7_isNash[l, 0, t]: True if for the t-th test with the l-th value of lambda, SPGD converges to a NE - PGD_S7_numIte[l, 0, t]: number of steps to convergence (or cycle) for SPGD of the t-th test with the l-th value of lambda - PGD_S7_valFin[l, 0, t]: final payoff reached by SBPD in the t-th test with l-th value of lambda - PGD_S7_valAvg[l, 0, t]: average payoff during the trajectory of SBPD in the t-th test with the l-th value of lambda - PGD_S7_time[l, 0, t]: time to run SBPD in the t-th test with l-th value of lambda. - Remark: SPGD is automatically stopped at the first check-point after 10 seconds run. - for SBRD: - SBRD_S7_isNash[l, 0, t]: True if for the t-th test with the l-th value of lambda, SBRD converges to a NE - SBRD_S7_numIte[l, 0, t]: number of steps to convergence (or cycle) for SBRD of the t-th test with the l-th value of lambda - SBRD_S7_val[l, 0, t]: NE payoff reached by SBRD in the t-th test with l-th value of lambda if SBRD converges to a NE, or average payoff along the cycle if SBRD converges to a cycle. - SBRD_S7_time[l, 0, t]: time to run SBRD in the t-th test with l-th value of lambda.</p>
<div id="bd73fe68" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Experimental setup</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>lambda_vals <span class="op">=</span> [<span class="fl">0.85</span><span class="op">+</span><span class="fl">0.09999999999</span><span class="op">*</span><span class="fl">0.25</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">7</span>)] <span class="co"># List of lambda values to test</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>A_vals <span class="op">=</span> [<span class="dv">100</span>]</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Outputs to Track</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Policy Gradient Dynamics</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>PGD_S7_isNash <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>) <span class="co"># {0,1} veridicity of Nash in Policy Gradient Dynamics</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>PGD_S7_numIte <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Number of iterations in Policy Gradient Dynamics</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>PGD_S7_valFin <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Final payoff for player 0 in Policy Gradient Dynamics</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>PGD_S7_valAvg <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Average payoff for player 0 in Policy Gradient Dynamics</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>PGD_S7_time <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))   <span class="co"># Runtime in Policy Gradient Dynamics</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a><span class="co">## Best Response Dynamics</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>SBRD_S7_isNash <span class="op">=</span> np.full((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples), <span class="va">False</span>, dtype<span class="op">=</span><span class="bu">bool</span>) <span class="co"># {0,1} veridicity of Nash in Best Response Dynamics</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>SBRD_S7_numIte <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Number of iterations in Best Response Dynamics</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>SBRD_S7_val <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples)) <span class="co"># Final payoff for player 0 in Best Response Dynamics</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>SBRD_S7_time <span class="op">=</span> np.zeros((<span class="bu">len</span>(lambda_vals), <span class="bu">len</span>(A_vals), samples))   <span class="co"># Runtime in Best Response Dynamics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="0b199b92" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>max_A <span class="op">=</span> A_vals[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Maximum number of actions (fixed at 50)</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">2025</span>) <span class="co">#We set the random seed for reproducibility </span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>T_0 <span class="op">=</span> time()  <span class="co"># Start the global timer</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> count_lam, lam <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_vals):  <span class="co"># Loop over correlation values</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(samples):  <span class="co"># Loop over sample repetitions</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate a shared reward matrix for both algorithms</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> generate_reward_matrix(<span class="dv">3</span>, max_A, lam)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> count_A, A <span class="kw">in</span> <span class="bu">enumerate</span>(A_vals):  <span class="co"># Loop over population sizes (fixed here)</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>            t_0 <span class="op">=</span> time()  <span class="co"># Start timer for PGD</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>            PGD_it, PGD_avg_val, PGD_val <span class="op">=</span> gradient_ascent_dynamics(G, A)</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> time() <span class="op">-</span> t_0  <span class="co"># Elapsed time</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>            PGD_S7_isNash[count_lam, count_A, i] <span class="op">=</span> (PGD_it <span class="op">&lt;</span> <span class="dv">50_000</span> <span class="op">-</span> <span class="dv">1</span>)  <span class="co"># Converged?</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>            PGD_S7_numIte[count_lam, count_A, i] <span class="op">=</span> PGD_it</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>            PGD_S7_valFin[count_lam, count_A, i] <span class="op">=</span> PGD_val</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>            PGD_S7_valAvg[count_lam, count_A, i] <span class="op">=</span> PGD_avg_val</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>            PGD_S7_time[count_lam, count_A, i] <span class="op">=</span> t</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># === Best Response Dynamics (SBRD) ===</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>            t_0 <span class="op">=</span> time()  <span class="co"># Start timer for SBRD</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>            SBRD_len, SBRD_it, SBRD_val_curr <span class="op">=</span> best_response_dynamics(G, A)</span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> time() <span class="op">-</span> t_0  <span class="co"># Elapsed time</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Store SBRD results</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>            SBRD_S7_isNash[count_lam, count_A, i] <span class="op">=</span> (SBRD_len <span class="op">==</span> <span class="dv">1</span>)  <span class="co"># Converged to pure NE?</span></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>            SBRD_S7_numIte[count_lam, count_A, i] <span class="op">=</span> SBRD_it</span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>            SBRD_S7_val[count_lam, count_A, i] <span class="op">=</span> SBRD_val_curr</span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>            SBRD_S7_time[count_lam, count_A, i] <span class="op">=</span> t</span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a><span class="co"># === Time Summary ===</span></span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a>Tot_time <span class="op">=</span> time() <span class="op">-</span> T_0</span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>Tot_time_SBRD <span class="op">=</span> np.<span class="bu">sum</span>(SBRD_S7_time)</span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a>Tot_time_PGD <span class="op">=</span> np.<span class="bu">sum</span>(PGD_S7_time)</span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>Tot_time_gener <span class="op">=</span> Tot_time <span class="op">-</span> Tot_time_SBRD <span class="op">-</span> Tot_time_PGD</span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Print runtime breakdown</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total time to run: </span><span class="sc">{</span><span class="bu">round</span>(Tot_time, <span class="dv">1</span>)<span class="sc">}</span><span class="ss"> s"</span>)</span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentage of the time spent on random generation of matrix: </span><span class="sc">{</span><span class="bu">round</span>((Tot_time_gener <span class="op">/</span> Tot_time) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">1</span>)<span class="sc">}</span><span class="ss">%"</span>)</span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentage of the time spent on SBRD algorithm: </span><span class="sc">{</span><span class="bu">round</span>((Tot_time_SBRD <span class="op">/</span> Tot_time) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">1</span>)<span class="sc">}</span><span class="ss">%"</span>)</span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Percentage of the time spent on PGD algorithm: </span><span class="sc">{</span><span class="bu">round</span>((Tot_time_PGD <span class="op">/</span> Tot_time) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">1</span>)<span class="sc">}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total time to run: 21041.3 s
Percentage of the time spent on random generation of matrix: 1.2%
Percentage of the time spent on SBRD algorithm: 0.0%
Percentage of the time spent on PGD algorithm: 98.7%</code></pre>
</div>
</div>
<p>As before, we see that SBRD takes less that 0.1% of the total running time. The largest proportion of the time is taken by SPGD. As before, SPGD is stopped at the first checkpoint after 10 seconds if convergence is not reached by then.</p>
<p>We first plot the average time as before. Notice that the scale is logarithmic!</p>
<div id="9c9347de" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S7_time"</span>, SBRD_varName<span class="op">=</span><span class="st">"S7_time"</span>, title<span class="op">=</span><span class="st">""</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>, expnr<span class="op">=</span><span class="st">"7"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Seconds"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-39-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We now plot the average value of equilibria attained by the two algorithms. As mentioned above, they both converge with high probability, therefore these values have statistical significance.</p>
<div id="cf9e58d0" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S7_valFin"</span>, SBRD_varName<span class="op">=</span><span class="st">"S7_val"</span>, title<span class="op">=</span><span class="st">""</span>, expnr<span class="op">=</span><span class="st">"7"</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Value"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, only_if_conv<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-40-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We plot the average number of steps to convergence (to a NE or to a cycle)</p>
<div id="99cabac1" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S7_numIte"</span>, SBRD_varName<span class="op">=</span><span class="st">"S7_numIte"</span>, title<span class="op">=</span><span class="st">""</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>,expnr<span class="op">=</span><span class="st">"7"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Steps"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, log<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-41-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>And finally, as before we compare the average final value (equilibrium or not) of SBRD against the average value attained by SPGD in its trajectory.</p>
<div id="c32aa08c" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>compare_algorithms(PGD_varName<span class="op">=</span><span class="st">"S7_valAvg"</span>, SBRD_varName<span class="op">=</span><span class="st">"S7_val"</span>, title<span class="op">=</span><span class="st">""</span>, expnr<span class="op">=</span><span class="st">"7"</span>, mean_1_name<span class="op">=</span><span class="st">"SPGD±2SE"</span>, mean_2_name<span class="op">=</span><span class="st">"SBRD±2SE"</span>, yLabel<span class="op">=</span><span class="st">"Value"</span>, axis<span class="op">=</span><span class="dv">1</span>, variance<span class="op">=</span><span class="va">True</span>, isPositive<span class="op">=</span><span class="va">True</span>, legend_loc<span class="op">=</span><span class="st">"upper right"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SBRD_files/figure-html/cell-42-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>